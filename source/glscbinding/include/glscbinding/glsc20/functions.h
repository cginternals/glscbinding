
#pragma once


#include <glscbinding/noglsc.h>
#include <glscbinding/glsc/functions.h>


namespace glsc20
{


using glsc::glActiveTexture;
using glsc::glBindBuffer;
using glsc::glBindFramebuffer;
using glsc::glBindRenderbuffer;
using glsc::glBindTexture;
using glsc::glBlendColor;
using glsc::glBlendEquation;
using glsc::glBlendEquationSeparate;
using glsc::glBlendFunc;
using glsc::glBlendFuncSeparate;
using glsc::glBufferData;
using glsc::glBufferSubData;
using glsc::glCheckFramebufferStatus;
using glsc::glClear;
using glsc::glClearColor;
using glsc::glClearDepthf;
using glsc::glClearStencil;
using glsc::glColorMask;
using glsc::glCompressedTexSubImage2D;
using glsc::glCreateProgram;
using glsc::glCullFace;
using glsc::glDepthFunc;
using glsc::glDepthMask;
using glsc::glDepthRangef;
using glsc::glDisable;
using glsc::glDisableVertexAttribArray;
using glsc::glDrawArrays;
using glsc::glDrawRangeElements;
using glsc::glEnable;
using glsc::glEnableVertexAttribArray;
using glsc::glFinish;
using glsc::glFlush;
using glsc::glFramebufferRenderbuffer;
using glsc::glFramebufferTexture2D;
using glsc::glFrontFace;
using glsc::glGenBuffers;
using glsc::glGenFramebuffers;
using glsc::glGenRenderbuffers;
using glsc::glGenTextures;
using glsc::glGenerateMipmap;
using glsc::glGetAttribLocation;
using glsc::glGetBooleanv;
using glsc::glGetBufferParameteriv;
using glsc::glGetError;
using glsc::glGetFloatv;
using glsc::glGetFramebufferAttachmentParameteriv;
using glsc::glGetGraphicsResetStatus;
using glsc::glGetIntegerv;
using glsc::glGetProgramiv;
using glsc::glGetRenderbufferParameteriv;
using glsc::glGetString;
using glsc::glGetTexParameterfv;
using glsc::glGetTexParameteriv;
using glsc::glGetUniformLocation;
using glsc::glGetVertexAttribPointerv;
using glsc::glGetVertexAttribfv;
using glsc::glGetVertexAttribiv;
using glsc::glGetnUniformfv;
using glsc::glGetnUniformiv;
using glsc::glHint;
using glsc::glIsEnabled;
using glsc::glLineWidth;
using glsc::glPixelStorei;
using glsc::glPolygonOffset;
using glsc::glProgramBinary;
using glsc::glReadnPixels;
using glsc::glRenderbufferStorage;
using glsc::glSampleCoverage;
using glsc::glScissor;
using glsc::glStencilFunc;
using glsc::glStencilFuncSeparate;
using glsc::glStencilMask;
using glsc::glStencilMaskSeparate;
using glsc::glStencilOp;
using glsc::glStencilOpSeparate;
using glsc::glTexParameterf;
using glsc::glTexParameterfv;
using glsc::glTexParameteri;
using glsc::glTexParameteriv;
using glsc::glTexStorage2D;
using glsc::glTexSubImage2D;
using glsc::glUniform1f;
using glsc::glUniform1fv;
using glsc::glUniform1i;
using glsc::glUniform1iv;
using glsc::glUniform2f;
using glsc::glUniform2fv;
using glsc::glUniform2i;
using glsc::glUniform2iv;
using glsc::glUniform3f;
using glsc::glUniform3fv;
using glsc::glUniform3i;
using glsc::glUniform3iv;
using glsc::glUniform4f;
using glsc::glUniform4fv;
using glsc::glUniform4i;
using glsc::glUniform4iv;
using glsc::glUniformMatrix2fv;
using glsc::glUniformMatrix3fv;
using glsc::glUniformMatrix4fv;
using glsc::glUseProgram;
using glsc::glVertexAttrib1f;
using glsc::glVertexAttrib1fv;
using glsc::glVertexAttrib2f;
using glsc::glVertexAttrib2fv;
using glsc::glVertexAttrib3f;
using glsc::glVertexAttrib3fv;
using glsc::glVertexAttrib4f;
using glsc::glVertexAttrib4fv;
using glsc::glVertexAttribPointer;
using glsc::glViewport;


} // namespace glsc20
